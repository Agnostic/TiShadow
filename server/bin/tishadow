#!/usr/bin/env node
var path = require("path"),
    fs = require("fs"),
    http = require("http"),
    util = require("util"),
    zipstream = require("zipstream"),
    base = process.cwd(),
    last_update,
    file_list;

function postToServer(path, data) {
  var jdata = JSON.stringify(data||{});
  var post_options = {
    host: 'localhost',
    port: '3000',
    path: path,
    method: 'POST',
    headers: {
      "Content-Type" : "application/json",
      "Content-Length":jdata.length
    } 
  };
  var req = http.request(post_options, function(res) {
    res.setEncoding('utf8');
    res.on('data', function (chunk) {
      console.log('Response: ' + chunk);
    });
  }); 
  req.write(jdata);
  req.end(); 
}

// Get Filelist with optional "update" filter
function getFileList(start, _path) {
  var files = [], dirs=[];
  var stat = fs.statSync(start);
  if (stat.isDirectory()) {
    var filenames = fs.readdirSync(start);
    var coll = filenames.reduce(function (acc, name) {
      var abspath = path.join(start, name);
      var file_stat = fs.statSync(abspath);
      if (file_stat.isDirectory()) {
        acc.dirs.push(name);
      } else {
        if (last_update === undefined || last_update < file_stat.mtime) {
          acc.names.push(path.join(_path || "." , name));
        }
      }
      return acc;
    }, {"names": [], "dirs": []});
    files = coll.names;
    coll.dirs.forEach(function (d) {
      var abspath = path.join(start, d);
      var relpath = path.join(_path|| ".", d);
      dirs.push(relpath);
      var recurs = getFileList(abspath, relpath);
      files = files.concat(recurs.files);
      dirs = dirs.concat(recurs.dirs);
    });
  }
  return {files: files, dirs: dirs};
};

// Recursively Remove Directories
var rmdir = function(dir) {
  var list = fs.readdirSync(dir);
  for(var i = 0; i < list.length; i++) {
    var filename = path.join(dir, list[i]);
    var stat = fs.statSync(filename);
    if(filename == "." || filename == "..") {
    } else if(stat.isDirectory()) {
      rmdir(filename);
    } else {
      fs.unlinkSync(filename);
    }
  }
  fs.rmdirSync(dir);
};
// Builds directory structure
function buildDirs(rel_root, dirs) {
  dirs.forEach(function(dir) {
    if (!path.existsSync(path.join(rel_root,dir)) ){
      fs.mkdirSync(path.join(rel_root,dir));
    }
  });
}
// Copies all Resource files and prepares JS files
function prepare(src, dst) {
  if (src.match("js$") && !src.match("underscore.js$")) {
    var src_text = "var p = require('/api/PlatformRequire'), log = require('/api/Log');\n" 
      + fs.readFileSync(src).toString()
        .replace(/(['"])\//g, "Ti.Filesystem.applicationDataDirectory+$1")
        .replace(/require/g, "p.require")
        .replace(/Ti.API/g, "log");
    fs.writeFileSync(dst,src_text);
  } else { // Non-JS file - just pump it
    var  is = fs.createReadStream(src);
    var  os = fs.createWriteStream(dst);
    util.pump(is, os);
  }
};

function zipbundle(files, callback, zip) {
  var out;
  if (zip === undefined) {
    out = fs.createWriteStream(path.join(base, "build", "tishadow", "dist", "bundle.zip"));
    zip = zipstream.createZip({level:1});
  }
  if (files.length === 0) {
    zip.finalize(callback);
  } else {
    var tail = files.splice(1);
    zip.addFile(fs.createReadStream(path.join(base,"build","tishadow","src",files[0])), {name: files[0]}, function() {
      zipbundle(tail,callback,zip);
    });
  }
  if (out) {
    zip.pipe(out);
  }
}

function touch() {
  var last_update_file = path.join(base, "build", "tishadow", "last_updated");
  if (path.existsSync(last_update_file)) {
    var now = new Date();
    fs.utimesSync(last_update_file,now,now);
  } else {
    fs.writeFileSync(last_update_file,"");
  }
}

var cmd = process.argv[2];
if (cmd === "server") {
  require("../app.js");
} else if (cmd === "clear") {
  postToServer("/clear_cache");
} else {
  if (!path.existsSync(path.join(base,'tiapp.xml'))) {
    console.log("Script must be executed in the Titanium project's root directory");
    process.exit();
  }

  console.log("Beginning Build Process");

  if(path.existsSync(path.join(base, 'build', 'tishadow', 'src')) 
    && path.existsSync(path.join(base, 'build', 'tishadow', 'last_updated'))
    && cmd == "update") {
    var last_stat = fs.statSync(path.join(base, 'build', 'tishadow', 'last_updated'));
    last_update = last_stat.mtime;
    file_list = getFileList(path.join(base, 'Resources'));
    if (file_list.files.length === 0) {
      console.log("Nothing to update.");
      process.exit();
    }
  } else {
    if (!path.existsSync(path.join(base,'build'))){
      fs.mkdirSync(path.join(base,'build'), 0755);
    }
    //Clean Build
    if (path.existsSync(path.join(base,'build','tishadow'))) {
      rmdir(path.join(base,'build','tishadow'));
    }
    // Create the tishadow build paths
    fs.mkdirSync(path.join(base,'build','tishadow'), 0755);
    fs.mkdirSync(path.join(base,'build','tishadow','src'), 0755);
    fs.mkdirSync(path.join(base,'build','tishadow','dist'), 0755);
    file_list = getFileList(path.join(base, 'Resources'));
  }

  // Process  Files
  buildDirs(path.join(base,'build','tishadow','src'), file_list.dirs);
  file_list.files.forEach(function(file) {
    prepare(path.join(base,'Resources',file), path.join(base,'build','tishadow','src', file));

  });

  // Bundle up to go
  var total = file_list.files.length;
  zipbundle(file_list.files,function(written) { 
    console.log(total+ " file(s) bundled."); 
    touch();
    postToServer("/", {bundle:path.join(base,"build","tishadow","dist","bundle.zip")}); 
  });

}
